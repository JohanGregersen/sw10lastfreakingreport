\subsubsection{Storage Server}\label{subsec:impl_storage_server}
In the implemented system, it was found to be simpler to implement the trip-processing layer as part of the logic layer. This does opposes the design decision to optimize the computational resources offered by the more powerful server. Monitoring the ongoing load on the API server, however shows that computation power is sufficient with a small set of users. The solution will however not scale well, and with more users this will have to be reworked to maximize the performance of the system. 

The trip-processing layer contains two extensive computational schemes named \texttt{GPSFactUpdater} and \texttt{TripFactUpdater}. The former computes all measures and flags between every GPS coordinate logged during the trip. This is the foundation for the entries inserted in the \texttt{TripFact} table and therefore has to be accurate. The modular design of classes is valuable in the context of processing trips, because appropriate objects can be chosen and forwarded to the \texttt{MeasureCalculator}. The \texttt{MeasureCalculator} contains mathematical formulas for calculating measures, for example how to compute speed. Only the appropriate sub classes are sent as parameters, and the complete object is not thrown around between formulas. 

\texttt{TripFactUpdater} computes the required attributes in the \texttt{TripFact}, which is statistical groupings of the information stored in the \texttt{GPSFact} table. It uses these statistical attributes to analyze driver performance, compute optimal- and actual tripscores. The scoringmodel, used to compute the actual tripscore, can be seen in Section \ref{subsec:prereq}.