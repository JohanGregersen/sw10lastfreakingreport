\subsubsection{API Server}\label{sec:api_server}
The API server contains three layers: A communication layer, logic layer, and data access layer.

The communication layer provides a uniform interface for both web- and smartphone clients, to communicate with the backend system. The communication layer is designed to be universal and service any device, be it Android, iOS, Windows Phone, Web, etc. This is achieved by hosting a RESTful Web Service on the API server, with a total of four service endpoints. A service endpoint is an enclosed subset of functionality, placed under a URL-extension to the base address (the IP-address to the server). Each endpoint offers a set of HTTP methods to access functionality in the logic layer. The four service endpoints are named Fact, Trip, Car, and Competition. Each service endpoint offers a structured way of communicating with the functionality in these four categories. As example, the Fact service endpoint offers three HTTP methods. Two of these use the HTTP GET verb, namely \texttt{GetFacts}, and \texttt{GetFactsForMap}. Both require a \texttt{CarId} and a \texttt{TripId} as parameters and returns the set of Facts corresponding to the parameters. When using \texttt{GetFactsForMap} the set of facts is trimmed to consist only of GPS coordinates and timestamps, because this is the minimal requirement for map display. The third method in the Fact service endpoint is a POST-method. It accepts a stream of trip data sent by a client upon ending a trip. Upon receiving this data, a request is passed on to the logic layer to process the stream of data.

The other three service endpoints function the same way, offering structured communication and utilizing the logical layer for determining which data to either process, or return to the client. The Trip service endpoint contains three HTTP-Get methods for a client to request. These methods return a single trip, trips corresponding to a specific user and a customized list of trips to present in a list, respectively. The Car service endpoint contains two HTTP-Get methods, and one HTTP-Update method: One HTTP-Get method for returning the data stored for a \texttt{CarId}, and another to get-or-create a new car in the system. The latter requires an IMEI number as a unique combination of numbers to identify the client. The HTTP-Update method is used whenever a client wants to provide the system with a desired username. The Competition service endpoint has a total of seven HTTP-methods, and will not be described thoroughly. It contains methods to return lists of competitions, and support the ability to sign-up and sign-down from available competitions.

Data exchanged by clients and the communication layer is wrapped in JSON-format. JSON is a lightweight format supported in many environments and languages. Using XML was also considered, but has an unnecessary overhead compared to JSON. GPX (GPS exchange format \citep{GPX_format}) was considered for when clients send raw trip data to the backend, but was not chosen due to poor support compared to JSON. It would furthermore require diversification in the formats used, which is considered unfavorable. To consider the use of GPX, a test should prove significant benefits in performance and data-overhead reduction, but such a test was not conducted due to prioritization of resources. 

The logic layer is extensive, complex and handles a wide range of functionality in the backend. The logic layer controls the resulting action when a client accesses a HTTP-method in the communication layer. In some cases, the logic behind a HTTP-method is trivial, causing the logic layer to simply request data from the data access layer. The logic layer then parses the raw data into appropriate classes which can be serialized using JSON. It then returns the result in proper format to the client. This serialization is designed to be very simple, because the system makes use of modularized classes. As an example, the \texttt{Fact} class only contains three simple properties: \texttt{EntryId}, \texttt{CarId} and \texttt{TripId}. An instance of the \texttt{Fact} class contains instances of six additional classes called Spatial, Temporal, Measure, Flag, Segment, and Quality. Each of these classes are serializable on their own, because they implement their own \texttt{DataContract}. A \texttt{DataContract} defines how to serialize a C\# object into JSON or XML format. Often a client only require a single module of the otherwise complex fact object. Having modular classes then allows for serializing simpler objects, which are to be sent using HTTP verbs.

The logical layer forwards the task of processing of new trips to the trip-processing layer. This layer is hosted on the more powerful of the two servers. This utilizes the computation power available on the two servers optimally, because trip-processing is the main consumer of computation power. Trip-processing is described in Section \ref{subsec:storageserver}. 

The data access layer (DAL) handles selecting, inserting, updating and removing data on the storage server. This layer has to work well with the choice of PostgreSQL as DBMS. A description of the physical data layer can be found in Section \ref{subsec:storageserver}. The DAL retrieves data from the physical data layer and returns references to C\# objects in the logic layer. This allows the DAL to provide simplified access to raw data. Queries in the DAL service can return both complete rows of data and customized selections. Conversion from raw data to class objects often includes extensive null checking in the logic layer, to eliminate null-reference exceptions, because the modularity of classes is not perfect. 